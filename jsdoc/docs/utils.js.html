<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

/**
 * @namespace Utils
 */

const { FFError } = require("./error");

const debug = require("util").debuglog("fireferret::utils");

const SYMBOLS = {
  EMPTY_QUERY: Symbol("EMPTY_QUERY"),
  EMPTY_OBJ: Symbol("EMPTY_OBJECT"),
  NULL_DOC: Symbol("NULL_DOC"),
  CACHE_HIT: Symbol("CACHE_HIT"),
  CACHE_MISS: Symbol("CACHE_MISS"),
};

const SPECIAL_CHARS = {
  QUERY_DELIMITER: "=",
  BUCKET_DELIMITER: "~",
};

/**
 * Pagination Options
 *
 * @typedef PaginationOptions
 * @property {Number} page - The page number.
 * @property {Number} size - The page size.
 * @property {Number} start - The starting index.
 * @property {Number} end - The ending index (exclusive)
 */
/**
 * Validates and reformats pagination options.
 * @memberof Utils
 *
 * @param {Object} options - The query options.
 *
 * @returns {PaginationOptions|null}
 */
function validatePaginationOpts(options) {
  if (!options) options = {};

  let { page, size } = options.pagination ? options.pagination : {};

  if (page &amp;&amp; size) {
    if (isNaN(page) || isNaN(size)) {
      throw new FFError(
        "InvalidOptions",
        "Pagination requires page and size to be numbers",
        "page::validatePaginationOpts",
        options.pagination
      );
    }

    page = Number(page);
    size = Number(size);

    if (page === 0) {
      throw new FFError(
        "InvalidOptions",
        "page is zero -- paginagion begins with page = 1",
        "page::validatePaginationOpts",
        options.pagination
      );
    }

    const start = (page - 1) * size;
    const end = page * size;

    return { page, size, start, end };
  }

  return null;
}

/**
 * Wide-Match strategy results.
 *
 * @typedef WideMatch
 * @property {String} targetQuery - A super-query that contains the requested query.
 * @property {Object} rangeOptions
 * @property {Number} rangeOptions.start - The starting index of the requested query's data (inclusive).
 * @property {Number} rangeOptions.end -  The starting index of the requested query's data (exclusive).
 */
/**
 * Determines if any perviously cached queries can be used to fulfill the current query.
 * @memberof Utils
 *
 * @param {Array} cachedQueries - A list of previously cached queries.
 * @param {PaginationOptions} pageOptions - Pagination options for the current query, if any.
 *
 * @returns {WideMatch|null}
 */
function filterAvailableWideMatch(cachedQueries, pageOptions) {
  if (!cachedQueries || cachedQueries.constructor.name !== "Array") {
    return null;
  }

  /* sort by shortest key */
  const sorted = cachedQueries.sort((a, b) => {
    return a.length - b.length;
  });

  /* push non-paginated query if it exists */
  if (sorted[0].split(/::/).length === 2) sorted.push(sorted.shift());

  for (const query of sorted) {
    const split = query.split(/::/);

    /* grab the params from the query, if they exist */
    const queryParams = split[2]
      ? split[2].length > 0
        ? split[2]
        : null
      : null;

    /* prefer to use smallest superset i.e. another paginated query */
    if (queryParams) {
      const { start, end } = JSON.parse(queryParams);

      /* goldilocks zone; not too hot, not too cold */
      if (start &lt;= pageOptions.start &amp;&amp; end >= pageOptions.end) {
        const _start = pageOptions.start - start;
        const _end = _start + (pageOptions.end - pageOptions.start);

        const ret = {
          targetQuery: query,
          rangeOptions: {
            start: _start,
            end: _end,
          },
        };

        debug("goldilocks zone match", _start, _end, query);
        return ret;
      }
    }

    /* mass look-up matched */
    if (!queryParams) {
      const ret = {
        targetQuery: query,
        rangeOptions: pageOptions,
      };
      return ret;
    }
  }

  /*  failed to match any existing query */
  return null;
}

/* @AamuLumi https://github.com/kb-dev/sanic.js */
function fastReverse(array) {
  let temp = null;
  const length = array.length;

  for (let i = 0, max = Math.floor(length / 2); i &lt; max; i++) {
    temp = array[i];
    array[i] = array[length - i - 1];
    array[length - i - 1] = temp;
  }

  return array;
}

module.exports = {
  SYMBOLS,
  SPECIAL_CHARS,
  validatePaginationOpts,
  filterAvailableWideMatch,
  fastReverse,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Options.html">Options</a></li><li><a href="Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="Bucket.html">Bucket</a></li><li><a href="Cache.html">Cache</a></li><li><a href="FerretError.html">FerretError</a></li><li><a href="FireFerret.html">FireFerret</a></li><li><a href="QueryKey.html">QueryKey</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.5</a> on Sat Sep 05 2020 16:19:50 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
